<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1
[
  <!ENTITY % entities SYSTEM "entity-decl.ent">
    %entities;
]>
<!-- Converted by suse-upgrade version 1.1 -->

<sect1 xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="s1-maintenance-custom-packages">
    <title>Uploading and Maintaining Custom Packages</title>
    <para>
        The mgrpush application allows you to serve custom packages associated
        with a private &susemgr; channel through the &susemgr; server. If you
        want the &susemgr; server to serve only official &sle; or &rhel;
        packages, you do not need to install <command>mgrpush</command>.
    </para>
    <para>
     All packages distributed through &susemgr; should have a
     digital signature. A digital signature is created with a unique
     private key and can be verified with the corresponding public
     key. After creating a package, the SRPM (Source RPM) and the RPM
     can be digitally signed with a GnuPG key. Before the package is
     installed, the public key is used to verify the package was
     signed by a trusted party and the package has not changed since
     it was signed.
    </para>
 <sect2 xml:id="s2-maintenance-custom-packages-gpg">
   <title>Generating a GnuPG Keypair</title>
   <para>
     A GnuPG keypair consists of the private and public keys. To generate a keypair, proceed as follows: 
   </para>
   <procedure>
   <step>
    <para>
     Type the following command as  &rootuser; on the shell prompt: 
    </para>
    <screen>
     gpg --gen-key
    </screen>
   </step>
   <step>
    <para>
     The command will prompt for key type. Choose option (2) DSA and ElGamal. This allows you to create a digital signature and encrypt/decrypt with two types of technologies.
    </para>
   </step>
   <step>
    <para>
     Choose the key size. The longer the key, the more resistant
     against attacks the messages are. Creating a key of at least 2048
     bits in size is recommended.
    </para>
   </step>
   <step>
    <para>
     Next, specify how long the key needs to be valid. When choosing
     an expiration date, remember that anyone using the public key
     must also be informed of the expiration and supplied with a new
     public key. We recommended to not select an expiration date. If
     you do not specify an expiration date, you are asked to confirm
     that the key should not expire.
    </para>
   </step>
   <step>
    <para>
      In the next steps, provide a User-ID containing your name, your
      email address, and an optional comment. When finished, you are
      presented with a summary of the information you entered. Accept
      your choices and enter a passphrase.
    </para>
   <note>
    <para>
     A good passphrase is essential for optimal security in GnuPG. Mix
     your passphrase with uppercase and lowercase letters, use
     numbers or punctuation marks.
    </para>
   </note>
   </step>
   <step>
    <para>
      Once you enter and verify your passphrase, the keys are
      generated. A message will ask you to move the mouse or otherwise
      interact with the system to generate random data for the
      key. This part of the key generation process may take several
      minutes.  When the activity on the screen ceases, your new keys
      are placed in the directory <systemitem>.gnupg</systemitem> in
      &rootuser;'s home directory. This is the default location for
      keys generated by the &rootuser; user.
    </para>
    <para>
      To list the &rootuser; keys, use the <command>gpg --list-keys</command> command.
    </para>
   </step>
   <step>
    <para>
      To retrieve the public key, use the command <command>gpg
      --list-keys</command> command. The public key is written to the file
      <filename>public_key.txt</filename>. This key must be deployed
      to all client systems that receive custom packages from
      &susemgr;. Techniques for deploying this key across an
      organization are covered in <xref linkend="ch-gpg-keys"/>
    </para>
   </step>
  </procedure>
 </sect2>
 <sect2 xml:id="s2-maintenance-custom-packages-sign">
   <title>Signing Custom Packages</title>
   <para>
     Before the <command>rpm</command> command can be used to sign packages, it needs to know the key to use. View the uid of your secret key:
   </para>
   <screen>
   gpg --list-secret-keys | grep uid
   </screen>
   <para>
    Add the following lines to the <filename>~/.rpmmacros</filename>
   </para>
   <screen>
    %_signature gpg 
    %_gpg_path /etc/rpm/.gpg 
    %_gpg_name <replaceable>secret_key_uid</replaceable> 
    %_gpgbin /usr/bin/gpg 
   </screen>
   <para>
     Replace <replaceable>secret_key_uid</replaceable> with exactly the output from the <command>gpg --list-secret-keys | grep uid</command> command. 
   </para>
   <note>
     <para>
      RPMs can be signed during or after build. Determine if a package has already been signed with the command: <command>rpm --qip</command> <replaceable>filename.rpm</replaceable>.
     </para>
   </note>
   <para>
    If the RPM is already signed, check whether the signature is correct. If the existing signature is not correct, resign the package:
   </para>
   <screen>
    rpm --resign <replaceable>filename.rpm</replaceable> 
   </screen>
   <para>
    If the RPM is not signed, sign it:
   </para>
   <screen>
    rpm --addsign <replaceable>filename.rpm</replaceable> 
   </screen>
   <para>
     Check the value of the "Signature" tag to ensure that the RPM has been signed correctly:
   </para>
   <screen>
    rpm -qip <replaceable>filename.rpm</replaceable> 
   </screen>

 </sect2>
 <sect2 xml:id="s2-maintenance-custom-packages-upload">
   <title>Uploading Custom Packages</title>
    <para>
        To use <command>mgrpush</command>, install the <systemitem class="resource">rhnpush</systemitem> 
        package and its dependencies. This package is available to registered &susemgr; Server systems and is installed by running <command>zypper in rhnpush</command>.
    </para>
    <para>
        mgrpush uploads RPM header information to the &susemgr; server database and places the RPM in the &susemgr; server package repository. <!-- Unlike the RHN Proxy Server's RHN Package Manager, RHN Push never distributes package information, even the headers, outside of the RHN Satellite Server database. -->
    </para>
    <para>
        When mgrpush is installed, a central configuration file is installed in <filename>/etc/sysconfig/rhn/rhnpushrc</filename>. This file contains default values for all the options, which are described in the mgrpush manual page (<command>man mgrpush</command>).
    </para>
    <para>
        Additionally, mgrpush looks for settings in the current directory (<filename>./.rhnpushrc</filename>) take precedent over those in the user's home directory (<filename>~/.rhnpushrc</filename>), which are used before those in the central configuration file (<filename>/etc/sysconfig/rhn/rhnpushrc</filename>).  These distinct configuration files are useful in varying  settings depending on the directory from which the mgrpush command is issued.
    </para>
    <para>For instance the current directory configuration file can be used to specify:</para>
<itemizedlist mark="bullet" spacing="normal">
 <listitem>
  <para>the software channel to be populated,</para>
 </listitem>
 <listitem>
  <para>the home directory configuration file to include the username to be invoked,</para>
 </listitem>
 <listitem>
  <para>the central configuration file to identify the server to receive the packages.</para>
 </listitem>
</itemizedlist>
    <!--
Table 6.2, “rhnpush options” contains all command line options for the rhnpush command:
Table 6.2. rhnpush options
Option 	Description
-v -\-verbose 	Increase verbosity, option can be used multiple times, that is, -vv, -vvv, and so forth.
-d, -\-dir DIRECTORY 	Process packages from this directory.
-c, -\-channel=CHANNEL_LABEL 	Specify the channel to receive packages. Note that this is required and is not the same as the channel's name. Multiple channels may be specified using multiple instances of -c (e.g. -c CHANNEL_ONE -c CHANNEL_TWO).
-n, -\-count N_HEADERS_PER_CALL 	Process this number of headers per call. Must be an integer. The default number is 25.
-l, -\-list 	List only the specified channels.
-r, -\-reldirRELATIVE_DIRECTORY 	Associate this relative directory with each file.
-o, -\-orgidORGANIZATION_ID 	Include your organization's ID number. Must be an integer.
-u , -\-username USERNAME 	Include the RHN username of the user that has administrative access to the specified channel. If not provided, rhnpush prompts for the username of a valid Channel Administrator. The username and password are cached in ~/.rhnpushcache for a limited time, five minutes being the default. Use -\-new-cache to force a new username and password.
-p , -\-password PASSWORD 	Include RHN password of user that has administrative access to the specified channel. If not provided, rhnpush prompts for the password of a valid Channel Administrator. The username and password are cached in ~/.rhnpushcache for a limited time, five minutes being the default. Use -\-new-cache to force a new username and password.
-s, -\-stdin 	Read package list from standard input, for example from a piped ls command.
-X, -\-exclude GLOB 	Exclude packages that match this glob expression.
-\-force 	Force upload of a package, even if a package of that name and version currently exists in the channel. Without this option, uploading a pre-existing package returns an error.
-\-nosig 	Don't fail if packages are unsigned.
-\-new-cache 	Forces RHN Push to drop the username and password cache, then accept or ask for new ones. This is useful if you make a mistake entering them the first time.
-\-newest 	Push only the packages that are newer than those on the server. Note that source packages are special in that their versions are never compared to each other. Their newness is dependent on their associated binary packages. Using this option with RHN Push and just a source package does upload the package, but the source package does not appear in the RHN Web interface until the associated binary package has been uploaded. Contrast this with -\-source. Using -\-source -\-newest together does update the stand-alone source package with newer packages and does not require an associated binary package to be uploaded first.
-\-header 	Upload only the headers.
-\-source 	Upload the indicated source packages. Doing this treats them as plain, stand-alone packages and not as special source packages associated with another, pre-existing binary package. For example, you can use this when you want to distribute application source to developers and testers outside of regular source control management.
-\-server SERVER 	Specify the server to which packages are uploaded. Currently, a value of http://localhost/APP is necessary. This parameter is required.
-\-test 	Only print a list of the packages to be pushed, don't actually push them.
-h, -\-help 	Briefly describe the options.
-?, -\-usage 	View the usage summary.
-->
    
    <!--
Tip
These command line options are also described in the rhnpush manual page: man rhnpush.
-->
 </sect2>
</sect1>
