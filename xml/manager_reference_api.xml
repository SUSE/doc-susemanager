<?xml version="1.0"?>
<?xml-stylesheet href="urn:x-suse:xslt:profiling:novdoc-profile.xsl" 
 type="text/xml"
 title="Profiling step"?>
<!DOCTYPE appendix PUBLIC
  "-//Novell//DTD NovDoc XML V1.0//EN" "novdocx.dtd"
[
  <!ENTITY % NOVDOC.DEACTIVATE.IDREF "INCLUDE">
  <!ENTITY % entities SYSTEM "entity-decl.ent">
  %entities;
]>
<appendix id="ap-rhn-api-access" os="hidden">
 <title>&susemgr; API Access</title><indexterm>
 <primary>account</primary>
 <secondary>API</secondary></indexterm>
 <para>
  To provide flexibility, &susemgr; offers an application programming
  interface (API). This interface can be accessed by clicking
  <guimenu>Help</guimenu> at the top-right corner of the &susemgr; Web interface,
  then clicking <guimenu>API</guimenu> in the left navigation bar.
  Alternatively, obtain a PDF from the URL <ulink
         url="http://www.suse.com/documentation/suse_manager/"/>.
  <remark>toms 2011-01-31: Which URL should be used for XMLRPC?
    Original says: https://rhn.redhat.com/rpc/api/</remark>
<!--Or you may go directly to:
  <ulink url="https://rhn.redhat.com/rpc/api/"/>. Use this URL for your
  XMLRPC server and your browser.-->
 </para>
 <para>
  The &susemgr; API is based on XML-RPC, which allows distinct pieces of
  software on disparate systems to make remote procedure calls using XML
  over HTTP. For this reason, any calls you make are expected to meet the
  constraints of XML-RPC. You can find out more at
  <ulink url="http://www.xmlrpc.com/"/>.
 </para>
 <para>
  This section bypasses a list of available methods and classes in favor of
  tips for using the API efficiently, including steps for determining
  required values. A sample script showcases some of the calls.
 </para>
 <sect1 id="s1-rhn-api-auth">
  <title>Using the auth Class and Getting the Session</title>

  <para>
   Note that you will almost invariably use the auth class first. This class
   offers a single method: login. Use this to establish a &susemgr; session.
   It requires values for three parameters: username, password, and
   duration. The first two come directly from your &susemgr; account, while
   the third is the length of time the session should last in seconds,
   typically 1200. It returns a session string than can be used in all other
   methods.
  </para>
 </sect1>
 <sect1 id="s1-rhn-api-systemid">
  <title>Obtaining the system_id</title>

  <para>
   Many of the methods require a value for the <option>system_id</option>
   parameter. This is the unique alphanumeric value assigned to each system
   when registered with &susemgr;. It can be found in the
   <filename>/etc/sysconfig/rhn/systemid</filename> file on each machine or
   obtained via the <option>download_system_id</option> method of the system
   class.
  </para>
 </sect1>
 <sect1 id="s1-rhn-api-sid">
  <title>Determining the sid</title>

  <para>
   Several methods require a value for the <option>sid</option>, or server
   ID, parameter. Note that this is different from the
   <option>system_id</option>. You may determine the <option>sid</option> of
   a machine in two different ways. You can log into the &susemgr; Web interface,
   click the name of a system, and view the <option>sid</option> at the end
   of the URL in the location bar. It follows the <literal>=</literal>
   symbol and is part of a string that resembles the following:
   <literal>index.pxt?sid=1003486534</literal> . Another way is to use the
   <option>list_user_systems</option> method of the system class to obtain a
   list of available systems and their associated <option>sid</option>s.
  </para>
 </sect1>
 <sect1 id="s1-rhn-api-cid">
  <title>Viewing the cid</title>

  <para>
   Like servers, channels have their own IDs. This value, the
   <option>cid</option>, is a required parameter for some methods, including
   <option>set_base_channel</option> and
   <option>set_child_channels</option>. Like the <option>sid</option>, the
   <option>cid</option> can be found on the &susemgr; Web interface. Just click on
   the name of a channel and view the end of the URL. The
   <option>cid</option> follows the <literal>=</literal> symbol, as part of
   a string that resembles the following:
   <literal>details.pxt?cid=54</literal> .
   <remark>emap 2011-03-22: I assume the period is supposed to be on a new
   line here and in the sid and sgid section.</remark>
  </para>
 </sect1>
 <sect1 id="s1-rhn-api-sgid">
  <title>Getting the sgid</title>

  <para>
   System groups also have their own IDs. This value, the
   <option>sgid</option>, is a required parameter for the
   <option>set_group_membership</option> method, for instance. Like the
   <option>sid</option> and <option>cid</option>, the <option>sgid</option>
   can be found on the &susemgr; Web interface. Just click on the name of a system
   group and view the end of the URL. It follows the <literal>=</literal>
   symbol, as part of a string that resembles the following:
   <literal>details.pxt?sgid=334958</literal> . Note that the member
   parameter within the <option>set_group_membership</option> method
   requires only <option>yes</option> or <option>no</option> as input to
   make the association.
  </para>
 </sect1>
 <sect1 id="s1-rhn-api-channel-labels">
  <title>Channel Labels</title>

  <para>
   The architecture of a channel is not always clear from the channel label.
   Below is a list that shows the correspondence between channel labels and
   the official title of the architecture they serve.
  </para>

  <table>
   <title>Channel Labels</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Channel Label
       </para>
      </entry>
      <entry>
       <para>
        Platform
       </para>
      </entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>
       <para>
        channel-i386-sun-solaris
       </para>
      </entry>
      <entry>
       <para>
        i386 Solaris
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        channel-ia32
       </para>
      </entry>
      <entry>
       <para>
        IA-32
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        channel-ia64
       </para>
      </entry>
      <entry>
       <para>
        IA-64
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        channel-sparc
       </para>
      </entry>
      <entry>
       <para>
        Sparc
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        channel-alpha
       </para>
      </entry>
      <entry>
       <para>
        Alpha
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        channel-s390
       </para>
      </entry>
      <entry>
       <para>
        IBM S/390
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        channel-s390x
       </para>
      </entry>
      <entry>
       <para>
        IBM System z
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        channel-iSeries
       </para>
      </entry>
      <entry>
       <para>
        IBM eServer System i
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        channel-pSeries
       </para>
      </entry>
      <entry>
       <para>
        IBM eServer System p
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        channel-x86_64
       </para>
      </entry>
      <entry>
       <para>
        AMD64 and Intel EM64T
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        channel-ppc
       </para>
      </entry>
      <entry>
       <para>
        PPC
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        channel-sparc-sun-solaris
       </para>
      </entry>
      <entry>
       <para>
        Sparc Solaris
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   To know the correct architecture is necessary for the
   channel.software.create method.
  </para>
 </sect1>
 <sect1 id="s1-rhn-api-script">
  <title>Sample API Script</title>

  <para>
   The following sample script shows how to construct a &susemgr; API
   client. Review the comments and links for a full description of the calls
   made.
  </para>

<screen>#!/usr/bin/perl -w

use strict;
use Frontier::Client;
use Data::Dumper;

############################################################################
# This is a sample script for use of the experimental Management APIs.     #
# The API is currently available using XMLRPC only, which is described in  #
# depth at:                                                                #
#                                                                          #
# http://www.xmlrpc.com/                                                   #
#                                                                          #
# We use the Frontier modules, available from:                             #
#                                                                          #
# http://theoryx5.uwinnipeg.ca/mod_perl/cpan-search?dist=Frontier-RPC      #
#                                                                          #
############################################################################


############################################################################
#   Defining an XMLRPC session.                                            #
############################################################################

# Define the host first.  This will be the FQDN of your &susemgr; system.
my $HOST = '.yourdomain.com';

# Now we create the client object that will be used throughout the session.

my $client = new Frontier::Client(url =&gt; &quot;http://$HOST/rpc/api&quot;);

# Next, we execute a login call, which returns a session identifier that will
# be passed in all subsequent calls.  The syntax of this call is described at:
#
#   http://$HOST/rpc/api/auth/login/

my $session = $client-&gt;call('auth.login', 'username', 'password');

############################################################################
#   System calls.                                                          #
############################################################################

# This next call returns a list of systems available to the user.  The 
# syntax of this call is described at:
#
#   http://$HOST/rpc/api/system/list_user_systems/
#
# In the code snippet below, we dump data about our systems, and we 
# capture the ID of the first system we find for future operations.

my $systems = $client-&gt;call('system.list_user_systems', $session);
for my $system (@$systems) {
  print Dumper($system);
}
print &quot;\n\nCapturing ID of system @$systems[0]-&gt;{name}\n\n&quot;;
my $systemid = @$systems[0]-&gt;{id};

# This next call returns a list of packages present on this system.  The
# syntax of this call is described at:
#
#   http://$HOST/rpc/api/system/list_packages/
#
# This will probably be a pretty long list.

my $packages = $client-&gt;call('system.list_packages', $session, $systemid);
for my $package (@$packages) {
  print Dumper($package);
}

# Additional system calls are described at:
#   http://$HOST/rpc/api/system/</screen>
 </sect1>
</appendix>
